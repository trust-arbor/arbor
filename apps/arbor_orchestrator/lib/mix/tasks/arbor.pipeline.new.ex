defmodule Mix.Tasks.Arbor.Pipeline.New do
  @shortdoc "Generate a new DOT pipeline from a template"
  @moduledoc """
  Scaffolds a new .dot pipeline file from built-in templates.

  ## Usage

      mix arbor.pipeline.new my_pipeline
      mix arbor.pipeline.new my_pipeline --template sdlc
      mix arbor.pipeline.new my_pipeline --dir specs/pipelines
      mix arbor.pipeline.new my_pipeline --goal "Build a REST API endpoint"

  ## Templates

  - `linear` (default) — Simple sequence: plan -> implement -> verify -> done
  - `sdlc` — Full SDLC: plan -> implement -> test -> review -> merge
  - `eval` — Evaluation pipeline: load -> run -> grade -> aggregate -> report
  - `branching` — Conditional routing: analyze -> choose strategy -> execute
  - `parallel` — Parallel fan-out/fan-in: split -> parallel work -> merge
  - `looping` — Retry loop: attempt -> check -> retry or done

  ## Options

  - `--template` / `-t` — Template name (default: linear)
  - `--dir` / `-d` — Output directory (default: specs/pipelines)
  - `--goal` / `-g` — Pipeline goal description
  - `--force` / `-f` — Overwrite existing file
  """

  use Mix.Task

  import Arbor.Orchestrator.Mix.Helpers

  @default_dir "specs/pipelines"

  @templates ~w(linear sdlc eval branching parallel looping)

  @impl true
  def run(args) do
    {opts, positional, _} =
      OptionParser.parse(args,
        strict: [
          template: :string,
          dir: :string,
          goal: :string,
          force: :boolean
        ],
        aliases: [t: :template, d: :dir, g: :goal, f: :force]
      )

    name =
      case positional do
        [name | _] ->
          name

        [] ->
          error(
            "Usage: mix arbor.pipeline.new <name> [--template linear|sdlc|eval|branching|parallel|looping]"
          )

          System.halt(1)
      end

    template = Keyword.get(opts, :template, "linear")
    dir = Keyword.get(opts, :dir, @default_dir)
    goal = Keyword.get(opts, :goal, "Describe the goal of this pipeline")
    force = Keyword.get(opts, :force, false)

    unless template in @templates do
      error("Unknown template: #{template}. Available: #{Enum.join(@templates, ", ")}")
      System.halt(1)
    end

    File.mkdir_p!(dir)
    filename = "#{sanitize_name(name)}.dot"
    path = Path.join(dir, filename)

    if File.exists?(path) and not force do
      error("File already exists: #{path}. Use --force to overwrite.")
      System.halt(1)
    end

    graph_id = camelize(name)
    content = generate_template(template, graph_id, goal)

    File.write!(path, content)
    success("Created #{path}")
    info("  Template: #{template}")
    info("  Graph ID: #{graph_id}")
    info("")
    info("Next steps:")
    info("  mix arbor.pipeline.compile #{path}         # Validate the pipeline")
    info("  mix arbor.pipeline.compile #{path} --verbose  # See handler types")
  end

  defp sanitize_name(name) do
    name
    |> String.replace(~r/[^a-zA-Z0-9_-]/, "_")
    |> String.downcase()
  end

  defp camelize(name) do
    name
    |> String.split(~r/[-_]/)
    |> Enum.map(&String.capitalize/1)
    |> Enum.join("")
  end

  # --- Templates ---

  defp generate_template("linear", id, goal) do
    """
    // #{id} — Linear Pipeline
    // Generated by: mix arbor.pipeline.new

    digraph #{id} {
      graph [
        goal="#{escape(goal)}",
        label="#{id}"
      ]

      start [shape=Mdiamond]

      plan [
        prompt="Given the goal: $goal, create a detailed plan. Include files to modify, design decisions, and verification steps.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      implement [
        prompt="Implement the plan from the previous step. Follow existing code patterns. The plan is in $last_response.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      verify [
        type="tool",
        tool_command="mix test --trace",
        max_retries="2"
      ]

      done [shape=Msquare]

      start -> plan -> implement -> verify
      verify -> done [condition="outcome=success"]
      verify -> implement [condition="outcome=fail", label="fix and retry"]
    }
    """
  end

  defp generate_template("sdlc", id, goal) do
    """
    // #{id} — SDLC Pipeline
    // Generated by: mix arbor.pipeline.new
    //
    // Phases: plan -> implement -> test -> review -> quality -> done
    // Human gates at review. Retry on test failures.

    digraph #{id} {
      graph [
        goal="#{escape(goal)}",
        label="#{id}",
        retry_policy="standard"
      ]

      start [shape=Mdiamond]

      plan [
        prompt="Given the goal: $goal, create a detailed implementation plan. Include: 1) Files to modify, 2) Design decisions, 3) Test strategy, 4) Risk assessment.",
        llm_model="claude-sonnet-4-5-20250929",
        reasoning_effort="high"
      ]

      implement [
        prompt="Implement the plan. Write clean, tested code following existing patterns. Plan is in $last_response.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      run_tests [
        type="tool",
        tool_command="mix test --trace",
        max_retries="2",
        retry_target="fix_tests"
      ]

      fix_tests [
        prompt="Tests failed. Analyze output in $tool.output and fix the root cause.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      review [
        shape=hexagon,
        prompt="Review the implementation for correctness, security, and style.",
        question="Implementation complete. Approve for merge?"
      ]

      quality_check [
        type="tool",
        tool_command="mix quality",
        max_retries="1"
      ]

      done [shape=Msquare, goal_gate="true"]

      start -> plan -> implement -> run_tests
      run_tests -> review [condition="outcome=success"]
      run_tests -> fix_tests [condition="outcome=fail"]
      fix_tests -> run_tests
      review -> quality_check [condition="outcome=success"]
      review -> implement [condition="outcome=fail", label="changes requested"]
      quality_check -> done [condition="outcome=success"]
      quality_check -> implement [condition="outcome=fail", label="quality issues"]
    }
    """
  end

  defp generate_template("eval", id, goal) do
    """
    // #{id} — Evaluation Pipeline
    // Generated by: mix arbor.pipeline.new
    //
    // Pattern: load dataset -> run subjects -> grade -> aggregate -> report

    digraph #{id} {
      graph [
        goal="#{escape(goal)}",
        label="#{id}"
      ]

      start [shape=Mdiamond]

      load_dataset [
        prompt="Load the evaluation dataset. Parse the JSONL file and extract test samples with inputs, expected outputs, and metadata. Output as JSON array.",
        llm_model="claude-haiku-4-5-20251001"
      ]

      run_subject [
        prompt="For each test sample, execute the subject under evaluation. Record the input, expected output, and actual output. Output results as JSON array.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      grade_results [
        prompt="Grade each result by comparing actual vs expected output. Apply graders: exact_match, contains, json_valid as appropriate. Output scored results as JSON.",
        llm_model="claude-haiku-4-5-20251001"
      ]

      aggregate [
        prompt="Compute aggregate metrics over all graded results: accuracy, mean_score, pass_at_k. Output metrics summary as JSON.",
        llm_model="claude-haiku-4-5-20251001"
      ]

      report [
        type="file.write",
        content_key="last_response",
        output="eval_report.json",
        format="json"
      ]

      done [shape=Msquare]

      start -> load_dataset -> run_subject -> grade_results -> aggregate -> report -> done
    }
    """
  end

  defp generate_template("branching", id, goal) do
    """
    // #{id} — Branching Pipeline
    // Generated by: mix arbor.pipeline.new
    //
    // Pattern: analyze -> choose strategy -> execute branch -> converge

    digraph #{id} {
      graph [
        goal="#{escape(goal)}",
        label="#{id}"
      ]

      start [shape=Mdiamond]

      analyze [
        prompt="Analyze the input and determine the best approach. Output your analysis and recommended strategy as one of: 'fast', 'thorough', 'hybrid'.",
        llm_model="claude-haiku-4-5-20251001"
      ]

      choose_strategy [shape=diamond]

      fast_path [
        prompt="Execute the fast approach: minimal processing, quick result. Prioritize speed over completeness.",
        llm_model="claude-haiku-4-5-20251001"
      ]

      thorough_path [
        prompt="Execute the thorough approach: comprehensive processing, high quality. Prioritize completeness over speed.",
        llm_model="claude-sonnet-4-5-20250929",
        reasoning_effort="high"
      ]

      converge [
        prompt="Validate and format the output from the chosen strategy path. Ensure consistency regardless of which path was taken.",
        llm_model="claude-haiku-4-5-20251001"
      ]

      done [shape=Msquare]

      start -> analyze -> choose_strategy
      choose_strategy -> fast_path [condition="context.strategy=fast"]
      choose_strategy -> thorough_path [condition="context.strategy=thorough"]
      choose_strategy -> fast_path [label="default"]
      fast_path -> converge
      thorough_path -> converge
      converge -> done
    }
    """
  end

  defp generate_template("parallel", id, goal) do
    """
    // #{id} — Parallel Pipeline
    // Generated by: mix arbor.pipeline.new
    //
    // Pattern: split -> parallel work streams -> fan-in merge

    digraph #{id} {
      graph [
        goal="#{escape(goal)}",
        label="#{id}"
      ]

      start [shape=Mdiamond]

      prepare [
        prompt="Analyze the task and split it into independent work streams that can run in parallel. Output the work items as a JSON array.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      fan_out [shape=component]

      stream_a [
        prompt="Execute work stream A from the parallel split.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      stream_b [
        prompt="Execute work stream B from the parallel split.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      fan_in [shape=tripleoctagon]

      merge [
        prompt="Merge results from all parallel work streams into a coherent output. Resolve any conflicts between streams.",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      done [shape=Msquare]

      start -> prepare -> fan_out
      fan_out -> stream_a
      fan_out -> stream_b
      stream_a -> fan_in
      stream_b -> fan_in
      fan_in -> merge -> done
    }
    """
  end

  defp generate_template("looping", id, goal) do
    """
    // #{id} — Looping Pipeline
    // Generated by: mix arbor.pipeline.new
    //
    // Pattern: attempt -> check quality -> retry or accept
    // Bounded by max_retries to prevent infinite loops.

    digraph #{id} {
      graph [
        goal="#{escape(goal)}",
        label="#{id}"
      ]

      start [shape=Mdiamond]

      attempt [
        prompt="Make an attempt at the task. Use feedback from previous attempts if available in $last_response.",
        llm_model="claude-sonnet-4-5-20250929",
        max_retries="5"
      ]

      check_quality [shape=diamond]

      refine [
        prompt="The previous attempt did not meet quality standards. Analyze what went wrong and produce an improved version. Previous result: $last_response",
        llm_model="claude-sonnet-4-5-20250929"
      ]

      done [shape=Msquare]

      start -> attempt -> check_quality
      check_quality -> done [condition="outcome=success"]
      check_quality -> refine [condition="outcome=fail"]
      refine -> attempt
    }
    """
  end

  defp escape(str) do
    String.replace(str, "\"", "\\\"")
  end
end
