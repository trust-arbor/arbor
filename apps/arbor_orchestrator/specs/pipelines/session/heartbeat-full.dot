// Heartbeat Variant: FULL — Everything persists between heartbeats
//
// This is the production heartbeat pipeline (identical to heartbeat.dot).
// All post-processing nodes are active: decompositions, proposals,
// working memory, identity (via route_actions), and goals.
//
// The control variant for the v3 memory ablation eval.
//
// ┌─────────────────────────────────────────────────────────────────────────┐
// │  TOOL LOOP: execute_actions -> check_loop -> llm_followup -> process   │
// │                                                                        │
// │  After the initial LLM call, actions are executed and results fed      │
// │  back to the LLM for another turn. The loop continues until the LLM   │
// │  returns no actions, or 10 tool turns are exhausted.                   │
// │  Each loop iteration processes ALL outputs (decompositions, goals,     │
// │  memory, identity) before checking for more actions.                   │
// └─────────────────────────────────────────────────────────────────────────┘

digraph HeartbeatFull {
  graph [
    goal="Execute one heartbeat with full memory persistence (all subsystems)",
    label="Heartbeat Full"
  ]

  // ── Entry ──────────────────────────────────────────────────
  start [shape=Mdiamond]

  // ── Background checks ─────────────────────────────────────
  bg_checks [type="session.background_checks"]

  // ── Cognitive mode selection ──────────────────────────────
  select_mode [type="session.mode_select"]

  // ── Mode routing ──────────────────────────────────────────
  mode_router [shape=diamond, condition_key="cognitive_mode"]

  // ── Mode-specific LLM calls ──────────────────────────────
  llm_goal [type="session.llm_call", cognitive_mode="goal_pursuit"]
  llm_reflect [type="session.llm_call", cognitive_mode="reflection"]
  llm_plan [type="session.llm_call", cognitive_mode="plan_execution"]
  consolidate [type="session.consolidate"]

  // ── Result processing (re-entered on tool loop cycles) ─────
  process [type="session.process_results"]

  // ── FULL: All post-processing nodes ───────────────────────
  store_decompositions [type="session.store_decompositions"]
  process_proposals [type="session.process_proposal_decisions"]
  store_identity [type="session.store_identity"]
  update_wm [type="session.update_working_memory"]
  execute_actions [type="session.execute_actions"]
  update_goals [type="session.update_goals"]

  // ── Tool loop control ──────────────────────────────────────
  check_loop [shape=diamond, condition_key="session.has_action_results"]
  llm_followup [type="session.llm_tool_followup"]

  // ── Exit ─────────────────────────────────────────────────
  done [shape=Msquare]

  // ══════════════════════════════════════════════════════════════
  // Flow
  // ══════════════════════════════════════════════════════════════

  start -> bg_checks -> select_mode -> mode_router

  mode_router -> llm_goal [condition="context.session.cognitive_mode=goal_pursuit"]
  mode_router -> llm_reflect [condition="context.session.cognitive_mode=reflection"]
  mode_router -> llm_plan [condition="context.session.cognitive_mode=plan_execution"]
  mode_router -> consolidate [condition="context.session.cognitive_mode=consolidation"]

  llm_goal -> process
  llm_reflect -> process
  llm_plan -> process
  consolidate -> process

  // Full tail: all post-processing, then tool loop check
  process -> store_decompositions -> process_proposals -> store_identity -> update_wm -> execute_actions -> update_goals -> check_loop

  // Tool loop: if actions produced results AND under 10 turns, follow up
  check_loop -> llm_followup [condition="context.session.has_action_results=true && context.session.tool_turn<10"]
  check_loop -> done

  // ── THE CYCLE ──────────────────────────────────────────────
  // LLM sees action results, produces new response, re-enters process
  llm_followup -> process
}
