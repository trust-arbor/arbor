{"id": "explain_genserver", "input": {"prompt": "Explain how GenServer works in Elixir. What are the key callbacks and when would you use it vs Agent?", "system": "You are a helpful Elixir programming assistant. Give clear, accurate explanations with code examples."}, "expected": {"contains": ["init", "handle_call", "handle_cast", "GenServer"], "min_length": 200}, "metadata": {"category": "explanation", "difficulty": "easy"}}
{"id": "debug_pattern_match", "input": {"prompt": "I'm getting a MatchError in this code:\n\n```elixir\n{:ok, result} = MyModule.maybe_fetch(key)\nIO.puts(result)\n```\n\nThe function sometimes returns `{:error, :not_found}`. How do I fix this?", "system": "You are a helpful Elixir programming assistant. Help debug the issue and suggest idiomatic solutions."}, "expected": {"contains": ["case", "pattern", "error"], "min_length": 100}, "metadata": {"category": "debugging", "difficulty": "easy"}}
{"id": "refactor_nested_case", "input": {"prompt": "Refactor this deeply nested code to be more idiomatic:\n\n```elixir\ndef process(input) do\n  case validate(input) do\n    {:ok, validated} ->\n      case transform(validated) do\n        {:ok, transformed} ->\n          case save(transformed) do\n            {:ok, saved} -> {:ok, saved}\n            {:error, reason} -> {:error, {:save_failed, reason}}\n          end\n        {:error, reason} -> {:error, {:transform_failed, reason}}\n      end\n    {:error, reason} -> {:error, {:validation_failed, reason}}\n  end\nend\n```", "system": "You are a helpful Elixir programming assistant. Suggest clean, idiomatic refactoring."}, "expected": {"contains": ["with"], "min_length": 100}, "metadata": {"category": "refactoring", "difficulty": "medium"}}
{"id": "supervisor_strategy", "input": {"prompt": "I have 3 GenServers: a Cache, a Worker, and a Logger. The Worker depends on the Cache but the Logger is independent. What supervisor strategy should I use and how should I structure the supervision tree?", "system": "You are a helpful Elixir programming assistant. Give practical OTP architecture advice."}, "expected": {"contains": ["one_for_one", "rest_for_one", "Supervisor"], "min_length": 150}, "metadata": {"category": "architecture", "difficulty": "medium"}}
{"id": "ecto_query_optimization", "input": {"prompt": "This Ecto query is slow:\n\n```elixir\nfrom(u in User,\n  join: p in Post, on: p.user_id == u.id,\n  where: u.active == true,\n  select: %{name: u.name, post_count: count(p.id)},\n  group_by: u.id\n)\n```\n\nThe users table has 1M rows and posts has 10M. What indexes would help and are there any query improvements?", "system": "You are a helpful Elixir programming assistant with Ecto and PostgreSQL expertise."}, "expected": {"contains": ["index", "users", "posts"], "min_length": 150}, "metadata": {"category": "performance", "difficulty": "hard"}}
{"id": "error_handling_patterns", "input": {"prompt": "What are the best practices for error handling in Elixir? When should I use try/rescue vs pattern matching vs let it crash?", "system": "You are a helpful Elixir programming assistant. Give comprehensive, practical advice."}, "expected": {"contains": ["let it crash", "pattern", "supervisor"], "min_length": 200}, "metadata": {"category": "best_practices", "difficulty": "medium"}}
