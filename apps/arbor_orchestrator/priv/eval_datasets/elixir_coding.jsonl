{"id": "genserver_kvstore", "input": {"prompt": "Write an Elixir GenServer module called `KVStore` that implements a simple key-value store with these features:\n\n1. `start_link/1` accepting an optional initial map\n2. `put(pid, key, value)` — stores a key-value pair (cast)\n3. `get(pid, key)` — retrieves a value, returns nil if missing (call)\n4. `delete(pid, key)` — removes a key (cast)\n5. `keys(pid)` — returns all keys as a list (call)\n6. `size(pid)` — returns the number of entries (call)\n\nUse proper GenServer callbacks. Include @moduledoc and typespecs.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the module code in a single ```elixir code block."}, "expected": {"module": "KVStore", "tests": [{"call": "KVStore.start_link([])", "match": "{:ok, _pid}"}, {"setup": "{:ok, pid} = KVStore.start_link([])", "call": "KVStore.size(pid)", "expect": "0"}, {"setup": "{:ok, pid} = KVStore.start_link([])\nKVStore.put(pid, :a, 1)\nProcess.sleep(50)", "call": "KVStore.get(pid, :a)", "expect": "1"}, {"setup": "{:ok, pid} = KVStore.start_link([])\nKVStore.put(pid, :a, 1)\nProcess.sleep(50)", "call": "KVStore.size(pid)", "expect": "1"}, {"setup": "{:ok, pid} = KVStore.start_link([])\nKVStore.put(pid, :a, 1)\nProcess.sleep(50)\nKVStore.delete(pid, :a)\nProcess.sleep(50)", "call": "KVStore.get(pid, :a)", "expect": "nil"}]}, "metadata": {"difficulty": "medium", "category": "otp", "tags": ["genserver", "state"]}}
{"id": "with_pipeline", "input": {"prompt": "Write an Elixir module called `UserValidator` with a function `validate/1` that takes a map and validates it using the `with` construct. The map should have:\n\n1. `\"name\"` — must be a non-empty string\n2. `\"email\"` — must contain `@`\n3. `\"age\"` — must be an integer >= 18\n\nReturn `{:ok, validated_map}` with atom keys on success, or `{:error, reason}` on first failure.\n\nUse pattern matching in the `with` clauses. Include typespecs.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the module code in a single ```elixir code block."}, "expected": {"module": "UserValidator", "tests": [{"call": "UserValidator.validate(%{\"name\" => \"Alice\", \"email\" => \"alice@example.com\", \"age\" => 25})", "match": "{:ok, %{name: \"Alice\", email: \"alice@example.com\", age: 25}}"}, {"call": "UserValidator.validate(%{\"name\" => \"\", \"email\" => \"alice@example.com\", \"age\" => 25})", "match": "{:error, _}"}, {"call": "UserValidator.validate(%{\"name\" => \"Alice\", \"email\" => \"no-at\", \"age\" => 25})", "match": "{:error, _}"}, {"call": "UserValidator.validate(%{\"name\" => \"Alice\", \"email\" => \"a@b\", \"age\" => 17})", "match": "{:error, _}"}]}, "metadata": {"difficulty": "easy", "category": "patterns", "tags": ["with", "validation"]}}
{"id": "stream_processing", "input": {"prompt": "Write an Elixir module called `LogAnalyzer` with a function `top_errors/2` that takes a list of log line strings and an integer `n`, returning the top `n` most frequent error messages.\n\nLog format: `\"[LEVEL] message\"` where LEVEL is INFO, WARN, or ERROR.\n\n1. Filter only ERROR level lines\n2. Extract the message part (after `[ERROR] `)\n3. Count occurrences of each unique message\n4. Return top `n` as a list of `{message, count}` tuples, sorted by count descending\n\nUse Stream or Enum pipelines. Include typespecs.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the module code in a single ```elixir code block."}, "expected": {"module": "LogAnalyzer", "tests": [{"setup": "logs = [\"[ERROR] timeout\", \"[INFO] ok\", \"[ERROR] timeout\", \"[ERROR] crash\", \"[WARN] slow\", \"[ERROR] timeout\"]", "call": "LogAnalyzer.top_errors(logs, 2)", "expect": "[{\"timeout\", 3}, {\"crash\", 1}]"}, {"call": "LogAnalyzer.top_errors([], 5)", "expect": "[]"}, {"setup": "logs = [\"[INFO] ok\", \"[WARN] slow\"]", "call": "LogAnalyzer.top_errors(logs, 3)", "expect": "[]"}]}, "metadata": {"difficulty": "medium", "category": "functional", "tags": ["stream", "enum", "pipeline"]}}
{"id": "protocol_impl", "input": {"prompt": "Define an Elixir protocol called `Describable` with a single function `describe/1` that returns a string description.\n\nThen implement it for:\n1. `Circle` struct with a `radius` field — describe returns `\"Circle with radius <r>\"`\n2. `Rectangle` struct with `width` and `height` fields — describe returns `\"Rectangle <w>x<h>\"`\n3. Any map (fallback) — returns `\"Map with <n> keys\"`\n\nInclude the protocol definition, struct definitions, and all implementations.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the code in a single ```elixir code block."}, "expected": {"module": "Describable", "tests": [{"call": "Describable.describe(%Circle{radius: 5})", "expect": "\"Circle with radius 5\""}, {"call": "Describable.describe(%Rectangle{width: 3, height: 4})", "expect": "\"Rectangle 3x4\""}, {"call": "Describable.describe(%{a: 1, b: 2})", "expect": "\"Map with 2 keys\""}]}, "metadata": {"difficulty": "medium", "category": "polymorphism", "tags": ["protocol", "struct"]}}
{"id": "agent_counter", "input": {"prompt": "Write an Elixir module called `Counter` that uses the Agent module to implement a simple counter with:\n\n1. `start_link/1` — starts with initial value (default 0)\n2. `value/1` — returns current value\n3. `increment/1` — adds 1\n4. `increment/2` — adds n\n5. `decrement/1` — subtracts 1\n6. `reset/1` — sets back to 0\n\nAll functions take the agent pid as first argument. Include typespecs.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the module code in a single ```elixir code block."}, "expected": {"module": "Counter", "tests": [{"call": "Counter.start_link(0)", "match": "{:ok, _pid}"}, {"setup": "{:ok, pid} = Counter.start_link(0)", "call": "Counter.value(pid)", "expect": "0"}, {"setup": "{:ok, pid} = Counter.start_link(10)", "call": "Counter.value(pid)", "expect": "10"}, {"setup": "{:ok, pid} = Counter.start_link(0)\nCounter.increment(pid)\nCounter.increment(pid, 5)", "call": "Counter.value(pid)", "expect": "6"}, {"setup": "{:ok, pid} = Counter.start_link(10)\nCounter.decrement(pid)", "call": "Counter.value(pid)", "expect": "9"}, {"setup": "{:ok, pid} = Counter.start_link(42)\nCounter.reset(pid)", "call": "Counter.value(pid)", "expect": "0"}]}, "metadata": {"difficulty": "easy", "category": "otp", "tags": ["agent", "state"]}}
{"id": "task_parallel", "input": {"prompt": "Write an Elixir module called `ParallelMap` with a function `pmap/2` that takes a list and a function, applies the function to each element in parallel using Task.async/Task.await, and returns the results in the same order.\n\nAlso implement `pmap/3` that accepts a timeout option (default 5000ms).\n\nHandle timeouts gracefully — return `{:error, :timeout}` for timed-out tasks.\n\nInclude typespecs.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the module code in a single ```elixir code block."}, "expected": {"module": "ParallelMap", "tests": [{"call": "ParallelMap.pmap([1, 2, 3], &(&1 * 2))", "expect": "[2, 4, 6]"}, {"call": "ParallelMap.pmap([], &(&1 + 1))", "expect": "[]"}, {"call": "ParallelMap.pmap([1, 2, 3], fn x -> x * x end)", "expect": "[1, 4, 9]"}]}, "metadata": {"difficulty": "medium", "category": "concurrency", "tags": ["task", "parallel", "async"]}}
{"id": "ets_cache", "input": {"prompt": "Write an Elixir module called `SimpleCache` that uses ETS to implement a TTL-based cache:\n\n1. `start/0` — creates the ETS table (returns table name)\n2. `put/3` — stores `{key, value}` with current timestamp\n3. `put/4` — stores with explicit TTL in seconds (default 300)\n4. `get/2` — retrieves value if not expired, returns `nil` if expired or missing\n5. `delete/2` — removes a key\n6. `size/1` — returns number of entries (including expired)\n7. `cleanup/1` — removes all expired entries\n\nThe table name should be `:simple_cache`. Store entries as `{key, value, inserted_at, ttl}`.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the module code in a single ```elixir code block."}, "expected": {"module": "SimpleCache", "tests": [{"call": "SimpleCache.start()", "expect": ":simple_cache"}, {"setup": "SimpleCache.start()", "call": "SimpleCache.put(:simple_cache, :key1, \"value1\")", "expect": "true"}, {"setup": "SimpleCache.start()\nSimpleCache.put(:simple_cache, :key1, \"value1\")", "call": "SimpleCache.get(:simple_cache, :key1)", "expect": "\"value1\""}, {"setup": "SimpleCache.start()", "call": "SimpleCache.get(:simple_cache, :missing)", "expect": "nil"}, {"setup": "SimpleCache.start()\nSimpleCache.put(:simple_cache, :a, 1)\nSimpleCache.put(:simple_cache, :b, 2)", "call": "SimpleCache.size(:simple_cache)", "expect": "2"}]}, "metadata": {"difficulty": "medium", "category": "storage", "tags": ["ets", "cache", "ttl"]}}
{"id": "supervisor_tree", "input": {"prompt": "Write an Elixir module called `WorkerSupervisor` that implements a simple Supervisor with:\n\n1. A `start_link/1` function that starts the supervisor\n2. Supervises a dynamic list of worker children using `:one_for_one` strategy\n3. Include a `start_worker/2` function that dynamically adds a child worker\n4. Include a `stop_worker/2` function that terminates a child\n5. Include a `list_workers/1` function that returns the count of active children\n\nThe workers should be simple GenServer processes that hold a name in their state.\nDefine the worker as an inner module `WorkerSupervisor.Worker`.", "system": "You are an expert Elixir developer. Write clean, idiomatic Elixir code. Return only the code in a single ```elixir code block."}, "expected": {"module": "WorkerSupervisor", "tests": [{"call": "WorkerSupervisor.start_link([])", "match": "{:ok, _pid}"}, {"setup": "{:ok, sup} = WorkerSupervisor.start_link([])", "call": "WorkerSupervisor.list_workers(sup)", "expect": "0"}]}, "metadata": {"difficulty": "medium", "category": "otp", "tags": ["supervisor", "dynamic"]}}
